---
title: Nestjs的专属队列：BullMQ
image: bullMQ.jpg
date: 2025-05-07
description: 探讨BullMQ作为Nestjs专属队列的优势，包括成本效益和功能特性。
keywords: BullMQ,Nestjs队列,Redis队列,后台任务处理,消息队列,分布式作业,任务调度,沙盒处理器,水平扩展,失败重试
---

## BullMQ

> BullMQ is a fast and robust background job processing library for Redis™

BullMQ 是一个基于 Redis 的后台任务处理库，实现了快速且健壮的队列系统。

BullMQ 提供了以下功能：

- 采用了无轮询设计，因此可最大限度地减少 CPU 使用率
- 基于 Redis 的分布式作业执行
- LIFO(后进先出) 和 FIFO(先进先出) 作业
- 优先级
- 延迟任务
- 使用 cron 设置计划和可重复的任务
- 失败作业的重试
- 为每个工作器设置并发
- 线程化（沙盒化）处理函数
- 从进程崩溃中自动恢复
- 父 - 子依赖关系

Nestjs 官方推荐使用 BullMQ，并为集成提供了`@nestjs/bullmq`包。

## 接下来

也许接下来我应该写一些关于 BullMQ 的使用教程。

但是这样很无趣，不是么，这些教程完全可以在官方文档中找到。

如何在 Nestjs 中集成 BullMQ，官方文档中也非常详细。

我不打算继续写教程了，虽然已经写了一部分。

我打算在后面去写 BullMQ 在实际开发中给我带来的一些便利，它是真的好用。

## 好用的地方

### 省钱！！！

我觉得这是最大的好用了。

通常我们提起队列，会想到`RabbitMQ`、`Kafka`、`RocketMQ`等。

但是它们都需要单独部署，维护，消耗资源。

BullMQ 是一个基于 Redis 的队列系统，不需要单独部署，维护，且大部分系统也都需要 Redis。

### 快速集成

相比于其他的队列，仅有一小部分支持 nodejs。

BullMQ 直接提供了 Nestjs 的集成包。

你可以按照官方教程，仅使用默认配置，就可以应对大部分的需求。

### 沙盒处理器

这应该是针对 nodejs 的单独功能。

由于 NodeJS 的本质是（一般情况下）单线程的。

当你需要处理 CPU 密集型任务时，需要使用多线程。

BullMQ 提供了沙盒处理器。

你可以在单独的处理其中执行任务，且完全支持 BullMQ 的所有功能。

### 简单粗暴的水平扩展

同一个队列，不同地方，定义多个生产者或消费者。

ok，就这么简单。

### 好用的调度器

BullMQ 提供了调度器，能够适应各种场景，包括按照固定时间间隔生成任务、根据 cron 表达式生成任务，或基于自定义需求生成任务。

当然最重要的是，它的失败重试和崩溃恢复机制，这在生产环境中简直太好用。

## 结束啦

以上就是我觉得 BullMQ 好用的地方啦。

掰掰~下次见！
